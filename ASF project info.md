# ASF project

Created: July 13, 2025 5:20 PM
Class: PMCSN

# ASF Project

## 1. Introduzione

Il caso di studio presentato in questo elaborato riguarda l’analisi delle prestazioni del processo di sviluppo software del progetto open source Apache BookKeeper, parte della Apache Software Foundation (ASF). L'obiettivo è applicare le tecniche di modellazione viste nel corso, e in particolare la teoria delle code, per rappresentare e valutare quantitativamente il ciclo di vita di una nuova funzionalità o correzione di bug: dalla creazione del ticket nel sistema di issue tracking Jira, attraverso le fasi di sviluppo e revisione collaborativa su GitHub, fino al rilascio finale.

La specificità di BookKeeper, come di altri progetti ASF, risiede nell’organizzazione basata su contributi volontari, processi decisionali trasparenti e collaborazione asincrona. Queste caratteristiche differenziano fortemente il flusso di lavoro rispetto a quello di una tipica azienda software, introducendo variabilità nei tempi di risposta, iterazioni multiple tra sviluppo, testing e bugfix, e la possibilità di cicli di revisione multipli prima della chiusura definitiva di una issue.

Il lavoro presentato segue una struttura classica di performance engineering: dopo la descrizione concettuale del sistema e la definizione degli obiettivi, viene costruito un modello a code per rappresentare i principali stati e transizioni del workflow di sviluppo. I parametri del modello verranno stimati tramite dati reali estratti dagli archivi pubblici di Jira e GitHub del progetto. Seguiranno la verifica di consistenza, la simulazione per la validazione del modello computazionale tramite confronto dei risultati prodotti con quelli rilevati e la proposta di possibili miglioramenti organizzativi basati sulle evidenze emerse.

## 2. Background e contesto open-source

Apache BookKeeper è un progetto open-source della Apache Software Foundation (ASF), il che significa che il suo sviluppo segue un modello di contributo volontario guidato dalla comunità piuttosto che un modello aziendale tradizionale. Nei progetti ASF non ci sono manager formali che assegnano i compiti; non si utilizza una classica strategia di gestione top-down (tipica delle organizzazioni gerarchiche, ma volunteer-driven, con i collaboratori che scelgono le questioni di loro interesse o più affini alle loro capacità.

Le decisioni vengono prese pubblicamente sulle mailing list o su GitHub attraverso la discussione e la votazione per consenso da parte della comunità. La cosiddetta "Apache Way" porta a un flusso di lavoro con caratteristiche uniche: le funzionalità e le correzioni sono sviluppate in modo collaborativo da volontari distribuiti geograficamente, facendo forte affidamento sulla comunicazione asincrona (e-mail, issue tracker) e sulla peer review. 

Non ci sono programmi fissi o deliverable formali definiti in anticipo, e la progettazione si evolve in modo iterativo. Queste differenze significano che la nostra analisi deve tenere conto di tempi più lenti (i volontari lavorano nelle ore libere), dimensioni variabili del team e progressi non lineari (i problemi possono rallentare o accelerare improvvisamente in base al numero di collaboratori attivi volta per volta). 

Allineeremo il nostro studio a questo contesto, in modo da cogliere le sfumature delle dinamiche di un progetto ASF piuttosto che assumere una rigida pipeline aziendale.

## 3. Analisi preliminare

Prima della definizione degli obiettivi abbiamo ritenuto necessario uno studio preliminare del dominio del problema al fine di ottenere una visione più completa possibile di ciò che riguarda la realtà attorno ASF,  lavorando su questi due punti principali:

- **Mappatura del flusso di lavoro:** Comprendere e modellare il flusso di sviluppo di BookKeeper come risulta da Jira e GitHub. Tracceremo il percorso di una nuova richiesta di funzionalità o di una segnalazione di bug attraverso le varie fasi del processo comunitario di Apache: dalla creazione del ticket iniziale, allo sviluppo e alla revisione del codice, ai test, alle iterazioni di correzione dei bug e infine al rilascio, tenendo conto delle pratiche dell'ASF (volunteer-driven work, consensus approval, and code review norms).
- **Tracciamento della vita delle funzionalità end-to-end:** Concentrarsi sull'intera vita di una funzionalità, dal ticket Jira "New Feature" alla sua messa in produzione (inclusa in una release che gli utenti distribuiscono). Verranno rilevati tutti gli stati intermedi e tutti i cicli (ad esempio, una funzionalità che richiede più cicli di test e correzione di bug prima di essere veramente pronta per la produzione in una release stabile).

## 4. Obiettivi

Il nostro obiettivo è studiare il ciclo di vita completo di una funzionalità o di un problema nel progetto Apache BookKeeper, dall'idea iniziale al rilascio finale. In particolare, ci proponiamo di:

- **Misurare le metriche chiave:** Analizzare quantitativamente il processo con metriche derivate dai dati di Jira e GitHub. Una metrica fondamentale sarà il tempo di risoluzione dei problemi (tempo di risposta), ovvero il tempo medio necessario affinché una funzionalità o una correzione di bug passi dall'inizio (creazione del ticket) alla risoluzione (chiusura in una release) con particolare attenzione al tempo d’attesa, che va dall’apertura del ticket alla presa in carico dello stesso da parte dello sviluppatore. Queste metriche forniranno una visione basata sui dati dell'efficienza del flusso di lavoro.
- **Identificare i colli di bottiglia e proporre miglioramenti:** Utilizzando le metriche di cui sopra e le osservazioni qualitative, individuiamo eventuali colli di bottiglia o inefficienze nel flusso di lavoro attuale. Ad esempio, cercheremo le fasi che dominano la tempistica (magari le revisioni del codice che richiedono molto tempo o i test che rivelano molti bug) e ne individueremo il motivo. Nella fase finale, proporremo miglioramenti concreti al processo di sviluppo e idee per ridurre i tempi di risposta. Queste raccomandazioni terranno conto della natura volontaria di ASF (ad esempio, migliorare l'automazione o la comunicazione, piuttosto che aspettarsi un impegno a tempo pieno da parte degli sviluppatori).
- Identificare il numero minimo

Raggiungendo questi obiettivi, non solo tracceremo il flusso di lavoro in dettaglio, ma forniremo anche indicazioni su come la comunità di BookKeeper possa potenzialmente semplificare il proprio processo di sviluppo, preservando i punti di forza della collaborazione aperta.

## 5. Ambito e fonti dei dati

La nostra analisi si concentra sull'issue tracker Jira e sul repository GitHub di Apache BookKeeper come fonti primarie di dati. L'attenzione a questi due sistemi copre sia il lato di gestione del progetto che quello di sviluppo del codice del flusso di lavoro:

- **Dati Jira**: Estrarremo tutti i problemi rilevanti da Jira di BookKeeper (che tiene traccia dei ticket per nuove funzionalità, miglioramenti, bug, ecc.). I campi chiave da raccogliere includono il tipo di problema, la cronologia dello stato (timestamp delle transizioni come Aperto → In corso → Risolto/Chiuso), la data di risoluzione e qualsiasi collegamento tra i problemi (ad esempio, un bug ticket collegato a una funzionalità). Jira fornisce un registro strutturato degli stati del flusso di lavoro formale che ogni problema attraversa. Mostrerà come i problemi passano attraverso stati come “*Aperto, In corso, Revisione del codice, Risolto, Chiuso”* e se vengono riaperti. Questi cambiamenti di stato e i loro timestamp ci permettono di ricostruire la cronologia della vita di ogni problema. Utilizzeremo Jira anche per identificare i cicli di iterazione - per esempio, se un problema è stato riaperto o se è stato creato un bug "sub-task" dopo che una funzionalità era stata presumibilmente completata, indicando che la funzionalità doveva passare attraverso un altro ciclo di correzione/test.
- **Dati GitHub**: Analizzeremo il repository GitHub di BookKeeper per la visione del codice, concentrandoci sulle Pull Request (PR), sui commit e sui risultati dei test di continuous integration (CI). Molti problemi di Jira hanno PR corrispondenti (gli sviluppatori spesso menzionano l'ID del problema di Jira nei messaggi di commit o nei titoli delle PR). Collegando i commit e le PR ai Jira Issues, possiamo vedere quando il codice è stato scritto e sottoposto a un merge per un determinato problema. GitHub ci dirà quando è stata aperta una PR, quanto tempo è rimasta in revisione del codice, quanti commit o revisioni ha attraversato e quando è stata finalmente  sottoposta a merge verso la codebase. Verranno anche analizzati i risultati della CI, ad esempio se i test di una PR non sono andati a buon fine, il che potrebbe essere correlato a un ulteriore sforzo di sviluppo o alla correzione di bug prima del merge. Correlando gli eventi di GitHub con i cambiamenti di stato di Jira, possiamo ottenere un quadro completo (ad esempio, un problema di Jira passa a "Risolto" nello stesso momento in cui la sua PR viene unita, e poi magari passa a "Chiuso" quando viene tagliata una release).

L'ambito è limitato alla storia e ai dati del progetto BookKeeper (non faremo confronti con altri progetti, se non come contesto). Probabilmente esamineremo un periodo significativo della storia del progetto (per esempio, gli ultimi anni di attività di sviluppo) per avere dati sufficienti sui cicli di vita delle funzionalità. Se disponibile e necessario, potremo incorporare altre fonti, come le discussioni nelle mailing list o i documenti di progettazione per un contesto qualitativo (ad esempio, per capire perché si sono verificati determinati ritardi), ma l'analisi principale sarà basata sui dati di Jira e GitHub. Questa analisi selettiva mantiene il progetto gestibile e assicura che il nostro studio rimanga fondato su prove derivate dagli artefatti di sviluppo del progetto.

## 6. Modello concettuale

## Flusso di lavoro

Il flusso di lavoro di Bookkeeper, così come quello di ogni software open source della ASF, si basa sul processo della comunità documentato tramite i software JIRA e GitHub, seguendo questi passi:

1. **Creazione di un ticket su JIRA:** Il lavoro di sviluppo inizia spesso con un nuovo ticket su Jira. Un collaboratore o un utente identifica un'esigenza, ad esempio una richiesta di funzionalità o una segnalazione di bug, e crea un issue in Jira (stato dell’issue= "*Aperto*"). Per semplicità il nostro caso di studio prende in considerazione solo i ticket che sono stati approvati in mailing list e che quindi verranno effettivamente sviluppati. Tutto ciò che accade prima dell’approvazione non è oggetto dello studio.
2. **Assegnazione dello sviluppo:** A differenza di un'azienda in cui è un manager ad assegnare i compiti, in BookKeeper un issue viene solitamente preso in carico da un volontario che ci lavora per un tempo di servizio (stato dell’issue = “*In Progress*”). Lo sviluppatore implementa la correzione o la funzionalità nel suo fork del repo e poi apre una richiesta di pull su GitHub. La descrizione della PR di solito fa riferimento all’issue di Jira (ad esempio, "BOOKKEEPER-XYZ: descrizione..."). L'apertura della PR segnala che il codice è pronto per la revisione. In questo momento, i test CI automatizzati vengono eseguiti sulla PR (stato dell’issue= “*Review*”).
3. **Revisione:** Perché la PR sia approvata un revisore deve analizzare il codice, se questa revisione ha esito negativo inizia un processo di revisione, comunemente composto anche da più cicli iterativi *Revisione → Sviluppo → Revisione*: i revisori possono richiedere modifiche, portando lo sviluppatore ad aggiornare la PR con nuovi commit. Una volta che la revisione avrà avuto esito positivo la PR viene unita al main branch di GitHub, questa modifica sarà quindi presente e disponibile nelle build snapshot o nella prossima release candidata, questo però non vuol dire che il processo è terminato perché è necessario passare alla fase di testing.
4. **Testing:** Vengono eseguiti test addizionali durante un periodo di osservazione per scoprire eventuali problemi, al termine di questa fase la feature viene effettivamente rilasciata. Qualora i nuovi test nel tempo considerato di “prova” rilevino dei nuovi problemi si attiva un meccanismo di feedback che riporta alla fase di sviluppo, in cui saranno necessari nuovi commit per fixare gli errori trovati, commit che verranno revisionati e poi passati nuovamente al testing.
Una volta passata anche la fase di testing si ha l’effettivo rilascio della funzionalità, ossia l’uscita del ticket dal sistema, che verrà consideranto *Resolved*